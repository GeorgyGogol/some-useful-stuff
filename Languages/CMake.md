# Язык CMake

Официальный сайт: https://cmake.org

Про физическую организацию сказано [тут](../ProjectOrganisation/PhysProjOrg/CMake.md), здесь - про
систему сборки и все необходимое

# New project Base

[Официальный туториал](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)

Для проекта нужно всего ничего - файл CMakeLists.txt и несколько колдовских слов. При изучении
очень не хватало сначала посмотреть на общую картину, так что начну с примерно общего файла. Тут я
постарался нарисовать основы, которые используются для написания CMakeLists.txt

```cmake
# Блок комментариев начинается с решетки

# Объявим минимальную версию CMake
cmake_minimum_required(VERSION 3.15) # См. в подробнее

# Определяем название проекта, версию и язык соответственно
project(
    ProjectName
    VERSION 0.1.0
    LANGUAGES CXX
)
# Эти строчки устанавливают требования к используемой версии языка C++
set(CMAKE_CXX_STANDARD 26) # <- Версия С++
set(CMAKE_CXX_STANDARD_REQUIRED True) # <- Ошибка, если такой версии нет
set(CMAKE_CXX_EXTENSIONS OFF) # <- Вот в этом не разобрался и как-то не хочется

# Вот эта штучка задает настройку сборки
option(ProjectName_LIB "Buid as lib" OFF)

# Это пример и объявления переменной, и сбора исходников проекта в одно место
set(
    SOURCES
    SomeClass.h
    SomeClass.cpp
    "Utils/ISomeUtil.h"
)
# Теперь мы можем обратиться к этой вещи через ${SOURCES}

# Тоже самое, только для директорий
set(
    INCLUDE_DIRS
    Utils
)

# Пример условного оператора
if(ProjectName_LIB)
    # Это вариант для ProjectName_LIB = ON
    # Собираем библиотеку динамической компановки
    add_library(ProjectName SHARED ${SOURCES})
    # Делаем алиас на модуль
    add_library(modules::ProjectName ALIAS ProjectName)
else()
    # Собираем исполняемый exe (если для винды)
    add_executable(ProjectName STATIC main.cpp )
endif(ProjectName_LIB) # Не обязательно, можно проще: endif()

# Теперь скажем, какие директории включаются в проект
target_include_directories(ProjectName PRIVATE ${INCLUDE_DIRS})
# А вот тут, какие файлы с исходным кодом добавить
target_sources(ProjectName PRIVATE ${SOURCES})

# Добавление поддиректории
add_subdirectory(subDir)
```

# Немного подробнее о заклинаниях

## Установка минимальной версии

```
cmake_minimum_required(VERSION <min>[...<policy_max>] [FATAL_ERROR])
```

Эта строка устанавливает версию CMake от минимальной min до максимальной policy_max. FATAL_ERROR
актуален для версий старше 2.6, для более свежих он игнорируется. Это заставляло CMake сваливаться
в ошибку, вместо предупреждения

## project()

Объявление проекта. Кроме представленных флагов можно добавить еще и DESCRIPTION с описанием
проекта (в двойных кавычках)

## option()

Определение опции сборки. В [примере выше](#New%20project%20Base) задается опция сборки
ProjectName_LIB для определения во что собирать проект - в исполняемый файл (для OFF) или
динамическую библиотеку (для ON). По-умолчанию (если не определить ON/OFF) будет являться OFF.

Задается до выполнения конфигурации в GUI или во время конфигурации командой:

```sh
cmake -D DProjectName_LIB=ON
```

(В команде не уверен)

Как видно, синтаксис примерно такой: "-D< optionName >=ON/OFF"

## add_executable

Определяет, что исходный код будет скомпилирован в исполняемый файл с соответствующим именем

## add_library

Определяет, что исходный код будет скомпилирован в библиотеку с соответствующим именем.

Библиотека может быть:

* STATIC - статичная (.lib для Win)
* SHARED - динамическая (.dll + .lib с точками входа для Win)

ALIAS определяет название библиотеки без разрешения на изменение включаемых в неё файлов и
настроек. Это позволяет:

1. Защитить от изменения
2. Выделить имя в определенное пространство имен, тем самым сепарировав таргет от общего бардака

## target_

Список подобных команд, относящихся к таргету:

* target_sources - указать исходники
* target_include_directories - указать директории включения
* target_link_libraries - указать связь с другими библиотеками

На примере очень жестко разделённых, но подробных переменных:

```cmake
# Задаем путь и файлы для внешнего интерфейса Project
# Они будут доступны внешним проектам
target_include_directories(Project PUBLIC ${SHARED_INCLUDE_PATH})
target_sources(Project PUBLIC ${SHARED_HEADER_FILES})

# Задаем путь и внутренние файлы Project
# Они НЕ будут доступны внешним проектам
target_include_directories(Project PRIVATE ${INCLUDE_PATH})
target_sources(Project PRIVATE ${HEADER_FILES})
target_sources(Project PRIVATE ${SOURCE_FILES})
```

## add_subdirectory()

Команда добавляет поддиректорию. Поддиректория является отдельным проектом, который будет добавлен
к основному, при этом:

1. Добавляемая поддиректория видит все, что уже было добавлено в основную
2. Вроде как, в поддиректории изменения происходят локально
3. При коллизии имен используется местный вариант

# Дополнительные приколдесы

## enable_testing()

Команда, включающая тестирование.

Собранный проект юнит-тестирования помещается в директорию testing

## Generating export header

**GenerateExportHeader**

Приколдес, актуальный для библиотек динамической линковки. Создает заголовочный файл, в котором
определеяется макрос импорта-экспорта:

```cmake
include(GenerateExportHeader)
generate_export_header(Project)
target_include_directories(Project PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
```

Эта часть абстрактного скрипта проекта Project создает заголовочный файл Project_export.h (в
директории с кэшем) и включает директорию с генерированным файлом в проект с публичным уровнем
доступа, который позволит увидеть оный внешним проектам

## Message

Тут все скучновато, но востребовано. Вывод сообщения производится с помощью метода
message(< Level > "< Text >"), где Text - это выводимый текст, а Level - уровень сообщения, который
может быть:

* STATUS - Уровень статуса. Выводится скопом со всеми сообщениями

# Колдовство в консоли

Итак, мы подготовили наш скрипт, будто это заклинание в книге. Теперь, чтобы ~~скастовать сборку~~
заставить это работать, мы должны ~~прочитать его~~ обратиться непосредственно к системе сборки
CMake с просьбой сделать это.

Весь процесс делится на два этапа: конфигурирование и сборка. И два пути: GUI и консоль. Далее -
про консоль.

## Конфигурирование

Первый шаг. Суть в том, чтобы сформировать кэш CMake и подготовить оный к сборке. Шаг может быть
выполнен непосредственно в директории (In-Source-Build, не рекомендуется), так и в поддиректории
(Out-Source-Build, рекомендуется). Фактически, мы скармливаем системе сборки наш CMakeLists.txt, и
она формирует кэш для дальнейшей сборки.

Командовать (для сборки в поддиректории build) так:

```sh
mkdir build
cd build
cmake ..
```

Таким образом, мы сформируем кэш для дельнейшего билда
## Сборка

Тут все более однозначно. В директории, в которой находится кэш, говорим:

```sh
cmake --build . --parallel
```

Это запустит сборку. Флаг parallel разрешает использовать более одного потока и выполнять сборку
параллельно

# Соус

За основу взято:

* Внешние ссылки базбросанные по документу
* https://habr.com/ru/articles/683204/
* https://habr.com/ru/articles/461817/

