* [Назад](./Readme.md)

- [Модули](#модули)
  - [add\_subdirectory](#add_subdirectory)
  - [include](#include)
  - [fetchContent](#fetchcontent)
  - [find\_package](#find_package)

# Модули

В настоящее время не нашел норм контента, который бы внятно объяснил, как правильно сделать свой модуль

Пока что решение для модульного проекта будет использовать add_subdirectory для подключения своих подмодулей/библиотек

CMake Модули и CMake конфигурации содержат в себе код на CMake скрипте. Несмотря на схожесть, это разные по назначению сущности. Модули, обычно расширяют поведение CMake, предоставляя функции, макросы и алгоритмы для использования в CMakeLists.txt, поставляются в комплекте с CMake, именуются как Find*.cmake и располагаются в `CMAKE_PREFIX_PATH`. Модули не привязаны к конкретному проекту и должны быть проектно-независимы. Проект может дополнять список модулей по необходимости при генерации или при использовании, но рекомендуется публиковать модули с целью включить их в состав дистрибутива CMake. Модули играют роль "Стандартной библиотеки CMake". Модули поддерживаются и разрабатываются мейнтейнерами CMake.

## add_subdirectory

Этот способ у меня заработал

Команда добавляет поддиректорию с CMakeLists. Поддиректория является отдельным проектом, который будет добавлен к основному, при этом:

1. Добавляемая поддиректория видит все, что уже было добавлено в основную
2. Вроде как, в поддиректории изменения происходят локально
3. При коллизии имен используется местный вариант

Смысл в том, чтобы свзязать два проекта, из разных репозиториев. Основной репозиторий, нужная ветка выкачивается в качестве подмодуля в зависимый. Зависимый проект подключает модуль с помощью команды add_subdirectory и связывается с базовым проектом с помощью target_link_libraries.

## include


## fetchContent


## find_package

Функция поиска cmake-пакетов. В первую очередь проверяет на наличие уже установленных пакетов.

