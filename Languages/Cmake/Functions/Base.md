* [Назад](../Readme.md)

- [Базовые заклинания](#базовые-заклинания)
  - [Установка минимальной версии Смакэ](#установка-минимальной-версии-смакэ)
  - [project()](#project)
  - [Настройки языка](#настройки-языка)
  - [option()](#option)
  - [add\_executable](#add_executable)
  - [add\_library](#add_library)
  - [target\_](#target_)
  - [file](#file)
  - [add\_subdirectory()](#add_subdirectory)

# Базовые заклинания

Маст хэв

## Установка минимальной версии Смакэ

```cmake
cmake_minimum_required(VERSION <min>[...<policy_max>] [FATAL_ERROR])
```

Эта строка устанавливает версию CMake от минимальной min до максимальной policy_max. FATAL_ERROR актуален для версий старше 2.6, для более свежих он игнорируется. Это заставляло CMake сваливаться в ошибку, вместо предупреждения

## project()

Объявление проекта, его название, которое может отличаться от названия приложения.

Кроме представленных флагов можно добавить еще и DESCRIPTION с описанием проекта (в двойных кавычках).

```cmake
project(ProjectName VERSION 1.0.0 LANGUAGES CXX)
```

Категорически против использования переменной CMAKE_PROJECT_NAME в качестве названия создаваемой единицы:

* Нет явной, точной определенности, с каким названием будет сделан проект (нет понимания, легко запутаться или потеряться)

## Настройки языка

Заклинание для C++:

```cmake
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_EXTENSIONS OFF)
```

## option()

Определение опции сборки. В [примере выше](#New%20project%20Base) задается опция сборки ProjectName_LIB для определения во что собирать проект - в исполняемый файл (для OFF) или динамическую библиотеку (для ON). По-умолчанию (если не определить ON/OFF) будет являться OFF.

Задается до выполнения конфигурации в GUI или во время конфигурации командой:

```sh
cmake -D DProjectName_LIB=ON
```

(В команде не уверен)

Как видно, синтаксис примерно такой: "-D< optionName >=ON/OFF"

## add_executable

Определяет, что исходный код будет скомпилирован в исполняемый файл с соответствующим именем

## add_library

Определяет, что исходный код будет скомпилирован в библиотеку с соответствующим именем.

Библиотека может быть:

* STATIC - статичная (.lib для Win)
* SHARED - динамическая (.dll + .lib с точками входа для Win)

ALIAS определяет название библиотеки без разрешения на изменение включаемых в неё файлов и настроек. Это позволяет:

1. Защитить от изменения
2. Выделить имя в определенное пространство имен, тем самым сепарировав таргет от общего бардака

## target_

Список подобных команд, относящихся к таргету:

* target_sources - указать исходники
* target_include_directories - указать директории включения
* target_link_libraries - указать связь с другими библиотеками

На примере очень жестко разделённых, но подробных переменных:

```cmake
# Задаем путь и файлы для внешнего интерфейса Project
# Они будут доступны внешним проектам и будут в них включены
target_include_directories(Project PUBLIC ${SHARED_INCLUDE_PATH})
target_sources(Project PUBLIC ${SHARED_HEADER_FILES})

# Задаем путь и внутренние файлы Project
# Они НЕ будут доступны внешним проектам
target_include_directories(Project PRIVATE ${INCLUDE_PATH})
target_sources(Project PRIVATE ${HEADER_FILES})
target_sources(Project PRIVATE ${SOURCE_FILES})
```

## file

Заклинание, которое собирает файлы

```cmake
file(SomeFiles GLOB src/*.cpp)
```

## add_subdirectory()

Команда добавляет поддиректорию с CMakeLists. Поддиректория является отдельным проектом, который будет добавлен к основному, при этом:

1. Добавляемая поддиректория видит все, что уже было добавлено в основную
2. Вроде как, в поддиректории изменения происходят локально
3. При коллизии имен используется местный вариант

