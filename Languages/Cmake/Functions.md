В этом разделе подробно рассмотрим заклинания, описывающие поведение сборки.

# Базовые заклинания

## Установка минимальной версии

```
cmake_minimum_required(VERSION <min>[...<policy_max>] [FATAL_ERROR])
```

Эта строка устанавливает версию CMake от минимальной min до максимальной policy_max. FATAL_ERROR актуален для версий старше 2.6, для более свежих он игнорируется. Это заставляло CMake сваливаться в ошибку, вместо предупреждения

## project()

Объявление проекта. Кроме представленных флагов можно добавить еще и DESCRIPTION с описанием проекта (в двойных кавычках)

## option()

Определение опции сборки. В [примере выше](#New%20project%20Base) задается опция сборки ProjectName_LIB для определения во что собирать проект - в исполняемый файл (для OFF) или динамическую библиотеку (для ON). По-умолчанию (если не определить ON/OFF) будет являться OFF.

Задается до выполнения конфигурации в GUI или во время конфигурации командой:

```sh
cmake -D DProjectName_LIB=ON
```

(В команде не уверен)

Как видно, синтаксис примерно такой: "-D< optionName >=ON/OFF"

## add_executable

Определяет, что исходный код будет скомпилирован в исполняемый файл с соответствующим именем

## add_library

Определяет, что исходный код будет скомпилирован в библиотеку с соответствующим именем.

Библиотека может быть:

* STATIC - статичная (.lib для Win)
* SHARED - динамическая (.dll + .lib с точками входа для Win)

ALIAS определяет название библиотеки без разрешения на изменение включаемых в неё файлов и настроек. Это позволяет:

1. Защитить от изменения
2. Выделить имя в определенное пространство имен, тем самым сепарировав таргет от общего бардака

## target_

Список подобных команд, относящихся к таргету:

* target_sources - указать исходники
* target_include_directories - указать директории включения
* target_link_libraries - указать связь с другими библиотеками

На примере очень жестко разделённых, но подробных переменных:

```cmake
# Задаем путь и файлы для внешнего интерфейса Project
# Они будут доступны внешним проектам
target_include_directories(Project PUBLIC ${SHARED_INCLUDE_PATH})
target_sources(Project PUBLIC ${SHARED_HEADER_FILES})

# Задаем путь и внутренние файлы Project
# Они НЕ будут доступны внешним проектам
target_include_directories(Project PRIVATE ${INCLUDE_PATH})
target_sources(Project PRIVATE ${HEADER_FILES})
target_sources(Project PRIVATE ${SOURCE_FILES})
```

## add_subdirectory()

Команда добавляет поддиректорию. Поддиректория является отдельным проектом, который будет добавлен к основному, при этом:

1. Добавляемая поддиректория видит все, что уже было добавлено в основную
2. Вроде как, в поддиректории изменения происходят локально
3. При коллизии имен используется местный вариант

# Дополнительные приколдесы

## enable_testing()

Команда, включающая тестирование.

Собранный проект юнит-тестирования помещается в директорию testing

## Generating export header

**GenerateExportHeader**

Приколдес, актуальный для библиотек динамической линковки. Создает заголовочный файл, в котором определеяется макрос импорта-экспорта:

```cmake
include(GenerateExportHeader)
generate_export_header(Project)
target_include_directories(Project PUBLIC ${CMAKE_CURRENT_BINARY_DIR})
```

Эта часть абстрактного скрипта проекта Project создает заголовочный файл Project_export.h (в
директории с кэшем) и включает директорию с генерированным файлом в проект с публичным уровнем доступа, который позволит увидеть оный внешним проектам

## Message

Тут все скучновато, но востребовано. Вывод сообщения производится с помощью метода
message(< Level > "< Text >"), где Text - это выводимый текст, а Level - уровень сообщения, который
может быть:

* STATUS - Уровень статуса. Выводится скопом со всеми сообщениями

