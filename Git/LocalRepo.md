* [Назад](./Readme.md)

- [Локальный репозиторий](#локальный-репозиторий)
- [Инициализация](#инициализация)
- [Управление внешними ссылками](#управление-внешними-ссылками)
- [Управление данными внешней ссылки](#управление-данными-внешней-ссылки)
- [Очистка рабочей копии](#очистка-рабочей-копии)
  - [Немного про флаги](#немного-про-флаги)
- [Submodule](#submodule)
- [Соус](#соус)

# Локальный репозиторий

Репозиторий (рабочая копия) на компьютере

# Инициализация

```sh
git init < --bare >
```

1. bare - голый репозиторий без рабочей директории. Т.е. получаем 
что-то типа репозитория-сервера, который может только хранить файлы,
без рабочей копии.

# Управление внешними ссылками

Добавить/Удалить внешний репозиторий:

```sh
git remote add <name> <path>
git remote remove <name>
```

Посмотреть, че там с/на удаленными репозиториями:

```sh
git remote -v
git remote show <name>
```

1. Получить все ссылки текущего, локального
2. Показать все связанное с уделенным name-репозитоирием:
   * Fetch-pull url-s
   * HEAD
   * И что-то еще по мелочи

Переопределить удаленный репозиторий:

```sh
git remote set-url <name> --push <path>
```

1. name - имя ссылки
2. push - опционально: место для пуша
3. path - новое место

# Управление данными внешней ссылки

Получить историю обновлений, статус:

```sh
git fetch < --all > <name>
```

* По дефлолту, простой фетч обратится по имени origin.
* all - это со всех подключенных удаленных.
* Ну, с name все понятно - имя удаленного.

Можно проверить удаленную ветку:

```sh
git checkout <ref-name>/<branch-name>
```

Получить данные:

```sh
git pull
```

> Команда git pull используется для синхронизации локальной рабочей копии и всех
> ссылочных объектов с удаленным репозиторием. По сути, git pull - это то же самое, что git
> fetch + git merge

Отправить данные:

```sh
git push <name> <aim-branch>
```

1. name - название, куда/в какой
2. aim-branch - название целевой ветки


# Очистка рабочей копии

Для очистки рабочей копии от неиндексированных, игнорируемых файлов и директорий
есть команда git clean

```sh
git clean
git clean -nfdx
git clean -dfx
git clean <flags> -- <path>
```

1. Очистка только родительской директории 
2. Просмотр удаляемых файлов и директорий
4. Полная очистка файлов и директорий
5. Очистка или просмотр удаляемого в path (может быть несколько path)

## Немного про флаги

По умолчанию будет очистка только не отслеживаемого и не игнорируемого файлов в
родительской директории (?)

| Флаг | Значение                                    |
| ---- | ------------------------------------------- |
| -n   | Тестовый прогон, отображение удаляемого     |
| -f   | Принудительно, т.е. удаление подтверждается |
| -d   | Удаление директорий                         |
| -x   | Удаление всего игнорируемого                |
| -i   | Интерактивный режим (не пользовался)        |

# Submodule

Репозиторий может включать в себя другие репозитории, выстраивая таким образом цепочки зависимостей. Это полезно при использовании модульной архитектуры: развитие базового и зависимого проекта идут независимо друг от друга, базовый проект может использоваться несколькими зависимыми.

Добавление происходит:

```sh
git submodule add -b branchName <repositoryUrl> <submodulePath>
git -c protocol.file.allow=always submodule add -b master <repositoryDir> <submodulePath>
```

* repositoryUrl - адрес репозитория; URL или "file://"
* submodulePath - полный относительный путь расположения, должен включать и название модуля
* Флаг b указывает, что нужно получить ветку branchName
* В дополнение можно указать флаг --depth < depth > (сколько последних коммитов получить)

Второе заклинание нужно для получения подмодуля внутри одной файловой системы

После чего создается [файл](Files.md#gitmodules), скачивается репозиторий, изменнения нужно зафиксировать коммитом. Командами init (--recurive для рекурсивной иницилизации) и deinit можно включить или выключить подмодуль, но мне не приходилось ими пользоваться. В основном репозитории подмодуль выглядит как цельная папка, без доступа к её содержимому. С самим подмодулем можно работать как с обычным реепозиторием...

Для удаления подмуодуля необходимо:

1. Удалить соответствующую запись в gitmodules
2. Удалить директорию с подмодулем

# Соус

* https://git-scm.com/docs/git-submodule
* https://stackoverflow.com/questions/1260748/how-do-i-remove-a-submodule/1260982#1260982

